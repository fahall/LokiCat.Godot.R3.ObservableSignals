using System.Text;
using LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.SyntaxHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.Generators;

internal static class RxPropertyGenerator
{
  internal static void Emit(
    GeneratorExecutionContext context,
    string className,
    string ns,
    string delegateName,
    ParameterDefinition parameters,
    string? inverseName,
    SemanticModel model)
  {
    var propertyName = GetRxPropertyName(delegateName);
    var signalBaseName = delegateName.EndsWith("EventHandler")
      ? delegateName[..^"EventHandler".Length]
      : delegateName;

    var fieldName = $"_now{propertyName}";
    var connectedFlag = $"_now{propertyName}Connected";

    var emitBody = new StringBuilder();
    emitBody.AppendLine(SignalEmitterGenerator.GetEmitCall(signalBaseName, parameters) + ";");

    if (inverseName is not null && BoolSignalCheck.IsSingleBoolParameter(parameters, model))
    {
      emitBody.AppendLine($"EmitSignal(nameof({inverseName}), !value);");
    }

    var source = $$"""
                   // <auto-generated />
                   using Godot;
                   using R3;
                   using System.CodeDom.Compiler;
                   using LokiCat.Godot.R3.RxProps;

                   namespace {{ns}};

                   public partial class {{className}} {
                     private readonly IRxVar<{{parameters.AggregateType}}> {{fieldName}} = new RxVar<{{parameters.AggregateType}}>();
                     private bool {{connectedFlag}};

                     [GeneratedCode("SignalObservableGenerator", "1.0.0")]
                     public IRxProp<{{parameters.AggregateType}}> {{propertyName}} {
                       get {
                         if (!{{connectedFlag}}) {
                           {{connectedFlag}} = true;
                           {{fieldName}}.AsObservable()
                             .Skip(1)
                             .Subscribe(value => {
                               {{emitBody.ToString().TrimEnd()}}
                             })
                             .AddTo(this);
                         }
                         return {{fieldName}};
                       }
                     }
                   }
                   """;

    context.AddSource($"{className}.{propertyName}.rx.g.cs", SourceText.From(source, Encoding.UTF8));
  }

  /// <summary>
  /// Prefix name with Is unless it's already prefixed with Now.
  /// </summary>
  /// <example>IsotopeEventHandler -> >NowIsotope</example>
  /// <example>IsIsotopeEventHandler -> >NowIsotope</example>
  /// <example>IsDeadEventHandler -> NowDead</example>
  /// <example>DeadEventHandler -> NowDead</example>
  /// <param name="delegateName"></param>
  /// <returns></returns>
  private static string GetRxPropertyName(string delegateName)
  {
    // Step 1: Remove "EventHandler" suffix
    var baseName = delegateName.EndsWith("EventHandler")
      ? delegateName[..^"EventHandler".Length]
      : delegateName;

    const string prefix = "Now";
    var index = prefix.Length;
    // Step 2: Strip "Now" only if it's a standalone prefix followed by an uppercase letter
    if (baseName.StartsWith(prefix) && baseName.Length >= index && char.IsUpper(baseName[index]))
    {
      baseName = baseName[index..];
    }

    // Step 3: Prefix "Now"
    return $"{prefix}{baseName}";
  }
}
