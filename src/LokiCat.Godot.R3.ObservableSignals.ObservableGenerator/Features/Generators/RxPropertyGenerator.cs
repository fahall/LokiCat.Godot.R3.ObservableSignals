using System.Text;
using LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.SyntaxHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.Generators;

internal static class RxPropertyGenerator
{
  internal static void Emit(
    GeneratorExecutionContext context,
    string className,
    string ns,
    string delegateName,
    ParameterDefinition parameters,
    string? inverseName,
    SemanticModel model)
  {
    var propertyName = GetRxPropertyName(delegateName);
    var signalBaseName = delegateName.EndsWith("EventHandler")
      ? delegateName[..^"EventHandler".Length]
      : delegateName;

    var fieldName = $"_is{propertyName}";
    var connectedFlag = $"_is{propertyName}Connected";
    var observableField = $"_on{signalBaseName}";

    var emitBody = new StringBuilder();
    emitBody.AppendLine(SignalEmitterGenerator.GetEmitCall(signalBaseName, parameters) + ";");

    if (inverseName is not null && BoolSignalCheck.IsSingleBoolParameter(parameters, model))
    {
      emitBody.AppendLine($"EmitSignal(nameof({inverseName}), !value);");
    }

    var source = $$"""
                   // <auto-generated />
                   using Godot;
                   using R3;
                   using R3.ReactiveProperty;
                   using System.CodeDom.Compiler;
                   using LokiCat.Godot.R3.RxProps;

                   namespace {{ns}};

                   public partial class {{className}} {
                     private readonly IRxVar<{{parameters.AggregateType}}> {{fieldName}} = new RxVar<{{parameters.AggregateType}}>();
                     private bool {{connectedFlag}};

                     [GeneratedCode("SignalObservableGenerator", "1.0.0")]
                     public IRxProp<{{parameters.AggregateType}}> {{propertyName}} {
                       get {
                         if (!{{connectedFlag}}) {
                           {{connectedFlag}} = true;
                           {{observableField}}.AsObservable().Subscribe(value => {
                             {{emitBody.ToString().TrimEnd()}}
                           }).AddTo(this);
                         }
                         return {{fieldName}};
                       }
                     }
                   }
                   """;

    context.AddSource($"{className}.{propertyName}.rx.g.cs", SourceText.From(source, Encoding.UTF8));
  }

  /// <summary>
  /// Prefix name with Is unless it's already prefixed with Is.
  /// </summary>
  /// <example>IsotopeEventHandler -> >IsIsotope</example>
  /// <example>IsIsotopeEventHandler -> >IsIsotope</example>
  /// <example>IsDeadEventHandler -> IsDead</example>
  /// <example>DeadEventHandler -> IsDead</example>
  /// <param name="delegateName"></param>
  /// <returns></returns>
  private static string GetRxPropertyName(string delegateName)
  {
    // Step 1: Remove "EventHandler" suffix
    var baseName = delegateName.EndsWith("EventHandler")
      ? delegateName[..^"EventHandler".Length]
      : delegateName;

    // Step 2: Strip "Is" only if it's a standalone prefix followed by an uppercase letter
    if (baseName.StartsWith("Is") && baseName.Length > 2 && char.IsUpper(baseName[2]))
    {
      baseName = baseName[2..];
    }

    // Step 3: Prefix "Is"
    return $"Is{baseName}";
  }
}
