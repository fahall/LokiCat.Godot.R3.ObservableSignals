using System.Text;
using LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.SyntaxHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.Generators;

internal static class RxPropertyGenerator
{
  private const string PUBLIC_PREFIX = "Is";
  private const string PRIVATE_PREFIX = "_is";

  
  internal static void Emit(
    GeneratorExecutionContext context,
    string className,
    string ns,
    string delegateName,
    ParameterDefinition parameters,
    string? inverseName,
    SemanticModel model)
  {
    
    context.ReportDiagnostic(Diagnostic.Create(
                               new DiagnosticDescriptor(
                                 "DEBUGPROP",
                                 "Debug",
                                 "Generating RxProp for: {0}",
                                 "Debug",
                                 DiagnosticSeverity.Info,
                                 true),
                               Location.None,
                               delegateName));
    
    var propertyName = GetRxPropertyName(delegateName);
    var signalBaseName = GetSignalBaseName(delegateName);
    var fieldName = GetRxVarName(delegateName);
    var connectedFlag = $"{fieldName}Connected";

    var emitBody = new StringBuilder();
    emitBody.AppendLine(SignalEmitterGenerator.GetEmitCall(signalBaseName, parameters.Count));

    if (inverseName is not null && BoolSignalCheck.IsSingleBoolParameter(parameters, model))
    {
      emitBody.AppendLine(SignalEmitterGenerator.GetCustomEmitCall(inverseName, "!value!"));
    }

    var source = $$"""
                   // <auto-generated />
                   using Godot;
                   using R3;
                   using System.CodeDom.Compiler;
                   using LokiCat.Godot.R3.RxProps;

                   namespace {{ns}};

                   public partial class {{className}} {
                     private readonly IRxVar<{{parameters.AggregateType}}> {{fieldName}} = new RxVar<{{parameters.AggregateType}}>();
                     private bool {{connectedFlag}};

                     [GeneratedCode("SignalObservableGenerator", "1.0.0")]
                     public IRxProp<{{parameters.AggregateType}}> {{propertyName}} {
                       get {
                         if (!{{connectedFlag}}) {
                           {{connectedFlag}} = true;
                           {{fieldName}}.AsObservable()
                             .Skip(1)
                             .Subscribe(value => {
                               {{emitBody.ToString().TrimEnd()}}
                             })
                             .AddTo(this);
                         }
                         return {{fieldName}};
                       }
                     }
                   }
                   """;

    context.AddSource($"{className}.{propertyName}.g.cs", SourceText.From(source, Encoding.UTF8));
  }

  private static string GetSignalBaseName(string delegateName, string suffixToTrim = "EventHandler")
  {
    // Step 1: Remove "EventHandler" suffix if present
    var baseName = delegateName.EndsWith(suffixToTrim)
      ? delegateName[..^suffixToTrim.Length]
      : delegateName;

    return baseName;
  }
  
  /// <summary>
  /// Prefix name with Is unless it's already prefixed with Is.
  /// </summary>
  /// <example>IsotopeEventHandler -> IsIsotope</example>
  /// <example>IsIsotopeEventHandler -> IsIsotope</example>
  /// <example>IsDeadEventHandler -> IsDead</example>
  /// <example>DeadEventHandler -> IsDead</example>
  /// <param name="baseName"></param>
  /// <returns></returns>
  private static string GetRxPropertyName(string baseName)
  {
    return DelegateWithPrefix(baseName, PUBLIC_PREFIX);
  }
  
  private static string GetRxVarName(string baseName)
  {
    return DelegateWithPrefix(baseName, PRIVATE_PREFIX);
  }

  private static string DelegateWithPrefix(string baseName, string prefix)
  {
    var index = prefix.Length;
    // Step 2: Strip prefix only if it's a standalone prefix followed by an uppercase letter
    if (baseName.StartsWith(prefix) && baseName.Length >= index && char.IsUpper(baseName[index]))
    {
      baseName = baseName[index..];
    }

    // Step 3: Prefix with desired prefix
    return $"{prefix}{baseName}";
  }
}
