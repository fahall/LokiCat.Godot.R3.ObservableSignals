using System.Text;
using LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.SyntaxHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.Generators;

internal static class RxPropertyGenerator
{
  internal static void Emit(
    GeneratorExecutionContext context,
    string className,
    string ns,
    string delegateName,
    ParameterDefinition parameters,
    string? inverseName,
    SemanticModel model)
  {
    
    context.ReportDiagnostic(Diagnostic.Create(
                               new DiagnosticDescriptor(
                                 "DEBUGPROP",
                                 "Debug",
                                 "Generating RxProp for: {0}",
                                 "Debug",
                                 DiagnosticSeverity.Info,
                                 true),
                               Location.None,
                               delegateName));
    
    var propertyName = GetRxPropertyName(delegateName);
    var signalBaseName = delegateName.EndsWith("EventHandler")
      ? delegateName[..^"EventHandler".Length]
      : delegateName;

    var fieldName = $"_is{propertyName}";
    var connectedFlag = $"_is{propertyName}Connected";

    var emitBody = new StringBuilder();
    emitBody.AppendLine(SignalEmitterGenerator.GetEmitCall(signalBaseName, parameters) + ";");

    if (inverseName is not null && BoolSignalCheck.IsSingleBoolParameter(parameters, model))
    {
      emitBody.AppendLine($"EmitSignal(nameof({inverseName}), !value);");
    }

    var source = $$"""
                   // <auto-generated />
                   using Godot;
                   using R3;
                   using System.CodeDom.Compiler;
                   using LokiCat.Godot.R3.RxProps;

                   namespace {{ns}};

                   public partial class {{className}} {
                     private readonly IRxVar<{{parameters.AggregateType}}> {{fieldName}} = new RxVar<{{parameters.AggregateType}}>();
                     private bool {{connectedFlag}};

                     [GeneratedCode("SignalObservableGenerator", "1.0.0")]
                     public IRxProp<{{parameters.AggregateType}}> {{propertyName}} {
                       get {
                         if (!{{connectedFlag}}) {
                           {{connectedFlag}} = true;
                           {{fieldName}}.AsObservable()
                             .Skip(1)
                             .Subscribe(value => {
                               {{emitBody.ToString().TrimEnd()}}
                             })
                             .AddTo(this);
                         }
                         return {{fieldName}};
                       }
                     }
                   }
                   """;

    context.AddSource($"{className}.{propertyName}.g.cs", SourceText.From(source, Encoding.UTF8));
  }

  /// <summary>
  /// Prefix name with Is unless it's already prefixed with Is.
  /// </summary>
  /// <example>IsotopeEventHandler -> IsIsotope</example>
  /// <example>IsIsotopeEventHandler -> IsIsotope</example>
  /// <example>IsDeadEventHandler -> IsDead</example>
  /// <example>DeadEventHandler -> IsDead</example>
  /// <param name="delegateName"></param>
  /// <returns></returns>
  private static string GetRxPropertyName(string delegateName)
  {
    // Step 1: Remove "EventHandler" suffix
    var baseName = delegateName.EndsWith("EventHandler")
      ? delegateName[..^"EventHandler".Length]
      : delegateName;

    const string PREFIX = "Is";
    var index = PREFIX.Length;
    // Step 2: Strip prefix only if it's a standalone prefix followed by an uppercase letter
    if (baseName.StartsWith(PREFIX) && baseName.Length >= index && char.IsUpper(baseName[index]))
    {
      baseName = baseName[index..];
    }

    // Step 3: Prefix with desired prefix
    return $"{PREFIX}{baseName}";
  }
}
