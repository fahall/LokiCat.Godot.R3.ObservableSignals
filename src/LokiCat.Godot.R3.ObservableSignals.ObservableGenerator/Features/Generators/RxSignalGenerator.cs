// <auto-generated />
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.SyntaxHelpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.Generators;

[Generator]
public sealed class RxSignalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var fields = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) =>
                    s is FieldDeclarationSyntax fieldDecl &&
                    fieldDecl.AttributeLists
                        .SelectMany(a => a.Attributes)
                        .Any(attr => attr.Name.ToString().Contains("RxSignal")),
                transform: static (ctx, _) => (FieldDeclarationSyntax)ctx.Node
            )
            .Where(static f => f is not null);

        var compilationAndFields = context.CompilationProvider.Combine(fields.Collect());

        context.RegisterSourceOutput(compilationAndFields, static (spc, source) =>
        {
            var (compilation, fieldList) = source;
            Execute(compilation, fieldList, spc);
        });
    }

    private static void Execute(Compilation compilation, IReadOnlyList<FieldDeclarationSyntax> fields, SourceProductionContext context)
    {
        AddRxSignalAttributeSource(context);

        var modelCache = new Dictionary<SyntaxTree, SemanticModel>();

        foreach (var group in fields.GroupBy(f => f.FirstAncestorOrSelf<ClassDeclarationSyntax>()))
        {
            if (group.Key is null)
                continue;

            var classDecl = group.Key;
            var namespaceName = Namespace.GetNamespace(classDecl);
            var className = classDecl.Identifier.Text;
            var builder = new StringBuilder();
            var generatedSomething = false;

            builder.AppendLine($$"""
// <auto-generated />
using Godot;
using R3;
using System.CodeDom.Compiler;

namespace {{namespaceName}};

public partial class {{className}}
{
""");

            foreach (var field in group)
            {
                if (!modelCache.TryGetValue(field.SyntaxTree, out var model))
                {
                    model = compilation.GetSemanticModel(field.SyntaxTree);
                    modelCache[field.SyntaxTree] = model;
                }

                var fieldSymbol = model.GetDeclaredSymbol(field.Declaration.Variables.First()) as IFieldSymbol;
                if (fieldSymbol == null)
                    continue;

                var hasRxSignal = fieldSymbol.GetAttributes()
                    .Any(attr => attr.AttributeClass?.ToDisplayString() == "LokiCat.Godot.R3.ObservableSignals.RxSignalAttribute");

                if (!hasRxSignal)
                    continue;

                var fieldType = fieldSymbol.Type;
                if (!IsObservableType(fieldType))
                {
                    context.ReportDiagnostic(Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "RXSG0002",
                            title: "Invalid RxSignal field",
                            messageFormat: $"Field '{fieldSymbol.Name}' must be assignable to Observable<T>.",
                            category: nameof(RxSignalGenerator),
                            DiagnosticSeverity.Warning,
                            isEnabledByDefault: true
                        ), fieldSymbol.Locations.FirstOrDefault()));
                    continue;
                }

                generatedSomething = true;

                var fieldName = fieldSymbol.Name;
                var baseName = ToSignalName(fieldName);
                var signalName = baseName;
                var delegateName = $"{baseName}EventHandler";
                var propertyName = $"On{baseName}";

                builder.AppendLine($$"""
    /// <summary>
    /// Godot signal emitted by {{propertyName}}.
    /// </summary>
    [Signal]
    public delegate void {{delegateName}}();

    private bool _{{baseName}}Connected = false;

    private void Ensure{{baseName}}Connected()
    {
        if (_{{baseName}}Connected) return;
        _{{baseName}}Connected = true;
        {{fieldName}}.Subscribe(_ => EmitSignal(nameof({{signalName}}))).AddTo(this);
    }

    /// <summary>
    /// Observable that emits when the {{signalName}} Godot signal is triggered.
    /// </summary>
    [GeneratedCode("RxSignalGenerator", "1.0.0")]
    public Observable<Unit> {{propertyName}}
    {
        get
        {
            Ensure{{baseName}}Connected();
            return {{fieldName}};
        }
    }
""");
            }

            builder.AppendLine("}");

            if (generatedSomething)
            {
                context.AddSource($"{className}.RxSignals.g.cs", builder.ToString());
            }
        }
    }

    private static bool IsObservableType(ITypeSymbol type)
    {
        return type.Name.StartsWith("Observable") || type.AllInterfaces.Any(i => i.Name.StartsWith("Observable"));
    }

    private static string ToSignalName(string fieldName)
    {
        if (fieldName.StartsWith("_on"))
            fieldName = fieldName.Substring(3);
        else if (fieldName.StartsWith("_"))
            fieldName = fieldName.Substring(1);

        return char.ToUpperInvariant(fieldName[0]) + fieldName.Substring(1);
    }

    private static void AddRxSignalAttributeSource(SourceProductionContext context)
    {
        const string source = """
        // <auto-generated />
        using System;

        namespace LokiCat.Godot.R3.ObservableSignals
        {
            [AttributeUsage(AttributeTargets.Field)]
            public sealed class RxSignalAttribute : Attribute
            {
                public RxSignalAttribute() { }
            }
        }
        """;

        context.AddSource("RxSignalAttribute.g.cs", source);
    }
}