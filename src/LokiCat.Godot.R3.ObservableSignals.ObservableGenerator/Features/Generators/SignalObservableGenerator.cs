// <auto-generated>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.SyntaxHelpers;

namespace LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.Generators;

[Generator]
public sealed class SignalObservableGenerator : ISourceGenerator
{
    private const string DIAGNOSTIC_ID = "SIGOBS001";

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        SignalObservableExtensionGenerator.EmitSignalObservableExtensions(context);
        AttributeGenerator.EmitInverseSignalAttributeDefinition(context);
        AttributeGenerator.EmitRxPropAttributeDefinition(context);
        AttributeGenerator.EmitRxObservableAttributeDefinition(context);
        EnvironmentValidation.ValidateEnvironment(context, DIAGNOSTIC_ID);
        foreach (var tree in context.Compilation.SyntaxTrees)
        {
            ProcessTree(context, tree);
        }
    }

    private static void ProcessTree(GeneratorExecutionContext context, SyntaxTree tree)
    {
        var allDelegates = tree.GetRoot()
                               .DescendantNodes()
                               .OfType<DelegateDeclarationSyntax>()
                               .Where(d => d.Identifier.Text.EndsWith("EventHandler"))
                               .ToList();

        var inverseMap = InverseSignalUtilities.GetInverseSignalMap(context, allDelegates);

        foreach (var delegateDecl in allDelegates.Where(d => d.HasAttribute(Attributes.RX_PROP) || d.HasAttribute(Attributes.RX_OBSERVABLE)))
        {
            CheckAndProcessDelegate(context, delegateDecl, inverseMap);
        }
    }

    private static void CheckAndProcessDelegate(GeneratorExecutionContext context, DelegateDeclarationSyntax delegateDecl,
        Dictionary<string, string> inverseMap)
    {
        var descriptor = new DiagnosticDescriptor(
            id: "DEBUG001",
            title: "Debug Diagnostic",
            messageFormat: "Generating for {0}",
            category: "ObservableSignals",
            DiagnosticSeverity.Warning, // ❗ Must be Warning or Error to ensure visibility
            isEnabledByDefault: true
        );

        context.ReportDiagnostic(Diagnostic.Create(descriptor, delegateDecl.GetLocation(), delegateDecl.Identifier.Text));

        
        if (!ShouldProcessDelegate(context, delegateDecl))
        {
            return;
        }

        ProcessDelegate(context, delegateDecl, inverseMap);

    }

    private static bool ShouldProcessDelegate(GeneratorExecutionContext context, DelegateDeclarationSyntax delegateDecl)
    {
        if (delegateDecl.HasAttribute(Attributes.INVERSE_SIGNAL))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                                         Diagnostics.InverseOnRxSignal,
                                         delegateDecl.GetLocation(),
                                         delegateDecl.Identifier.Text
                                     ));
            return false;
        }

        if (delegateDecl.HasAttribute(Attributes.RX_PROP) && delegateDecl.HasAttribute(Attributes.RX_OBSERVABLE))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                                         Diagnostics.ConflictingRxAttributes,
                                         delegateDecl.GetLocation(),
                                         delegateDecl.Identifier.Text
                                     ));
            return false;
        }

        return true;
    }

    private static void ProcessDelegate(
        GeneratorExecutionContext context,
        DelegateDeclarationSyntax delegateDecl,
        Dictionary<string, string> inverseMap)
    {
        try
        {
            var classDecl = delegateDecl.Parent as ClassDeclarationSyntax;

            if (classDecl is null)
            {
                return;
            }
            
            context.ReportDiagnostic(Diagnostic.Create(
                                         new DiagnosticDescriptor(
                                             "DEBUGGEN",
                                             "Debug",
                                             "Processing delegate: {0}",
                                             "Debug",
                                             DiagnosticSeverity.Info,
                                             true),
                                         delegateDecl.GetLocation(),
                                         delegateDecl.Identifier.Text));

            var className = classDecl.Identifier.Text;
            var ns = Namespace.GetNamespace(classDecl);
            var parameters = new ParameterDefinition(delegateDecl);

            var model = context.Compilation.GetSemanticModel(delegateDecl.SyntaxTree);

            var delegateName = delegateDecl.Identifier.Text;
            var signalName = delegateName[..^"EventHandler".Length];

            inverseMap.TryGetValue(delegateName, out var inverseName);

            if (delegateDecl.HasAttribute(Attributes.RX_PROP))
            {
                RxPropertyGenerator.Emit(
                    context,
                    className,
                    ns,
                    delegateName,
                    parameters,
                    inverseName,
                    model
                );
            }
            else if (delegateDecl.HasAttribute(Attributes.RX_OBSERVABLE))
            {
                RxObservableGenerator.Emit(
                    context,
                    className,
                    ns,
                    signalName,
                    parameters,
                    inverseName,
                    model
                );
            }
        }
        catch (TooManyParametersException)
        {
            context.ReportDiagnostic(Diagnostic.Create(Diagnostics.TooManyParameters, delegateDecl.GetLocation()));
        } 
    }
}