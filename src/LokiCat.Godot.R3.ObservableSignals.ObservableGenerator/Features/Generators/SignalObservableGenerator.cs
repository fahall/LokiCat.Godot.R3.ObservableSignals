// <auto-generated />
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.SyntaxHelpers;

namespace LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.Generators;

[Generator]
public sealed class SignalObservableGenerator : ISourceGenerator
{
    private const string DIAGNOSTIC_ID = "SIGOBS001";
    private const string DIAGNOSTIC_CATEGORY = "SignalObservables";

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        EmitSignalObservableExtensions(context);

        foreach (var tree in context.Compilation.SyntaxTrees)
        {
            ProcessTree(context, tree);
        }
    }

    private static void ProcessTree(GeneratorExecutionContext context, SyntaxTree tree)
    {
        var root = tree.GetRoot();
        var delegateDeclarations = root
            .DescendantNodes()
            .OfType<DelegateDeclarationSyntax>()
            .Where(d => d.AttributeLists
                .SelectMany(a => a.Attributes)
                .Any(attr => attr.Name.ToString().Contains("Signal")));

        foreach (var delegateDecl in delegateDeclarations)
        {
            ProcessDelegate(context, delegateDecl);
        }
    }

    private static void ProcessDelegate(GeneratorExecutionContext context, DelegateDeclarationSyntax delegateDecl)
    {
        var parameters = delegateDecl.ParameterList.Parameters;
        var paramCount = parameters.Count;

        if (paramCount > 5)
        {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    DIAGNOSTIC_ID,
                    title: "Signal has too many parameters",
                    messageFormat: "[Signal] delegate '{0}' has more than 5 parameters — observable not generated.",
                    category: DIAGNOSTIC_CATEGORY,
                    DiagnosticSeverity.Warning,
                    isEnabledByDefault: true),
                delegateDecl.GetLocation(),
                delegateDecl.Identifier.Text
            );
            context.ReportDiagnostic(diagnostic);
            return;
        }

        var delegateName = delegateDecl.Identifier.Text;
        var signalName = delegateName.EndsWith("EventHandler")
            ? delegateName.Substring(0, delegateName.Length - "EventHandler".Length)
            : delegateName; // fallback if not matching convention

        var propertyName = $"On{signalName}";
        var paramTypes = parameters.Select(p => p.Type?.ToString() ?? "object").ToList();

        var observableType = paramTypes.Count switch
        {
            0 => "Unit",
            1 => paramTypes[0],
            2 => $"({paramTypes[0]}, {paramTypes[1]})",
            3 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]})",
            4 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]}, {paramTypes[3]})",
            5 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]}, {paramTypes[3]}, {paramTypes[4]})",
            _ => throw new System.InvalidOperationException()
        };

        var classDecl = delegateDecl.Parent as ClassDeclarationSyntax;
        if (classDecl is null)
            return;

        var className = classDecl.Identifier.Text;
        var ns = Namespace.GetNamespace(classDecl);
        var code = GenerateObservablePropertyCode(ns, className, signalName, propertyName, observableType);

        context.AddSource($"{className}.{propertyName}.g.cs", code);
    }

    private static string GenerateObservablePropertyCode(string ns, string className, string signalName, string propertyName, string observableType)
    {
        var fieldName = $"_{char.ToLowerInvariant(propertyName[0])}{propertyName.Substring(1)}";

        return $$"""
            // <auto-generated />
            using Godot;
            using R3;
            using LokiCat.Godot.R3.ObservableSignals;

            namespace {{ns}};

            public partial class {{className}} {
              private Observable<{{observableType}}> {{fieldName}};
              public Observable<{{observableType}}> {{propertyName}} =>
                this.Signal(nameof({{signalName}}), ref {{fieldName}});
            }
            """;
    }

    private static void EmitSignalObservableExtensions(GeneratorExecutionContext context)
    {
        SignalObservableExtensionGenerator.EmitSignalObservableExtensions(context);
    }
}
