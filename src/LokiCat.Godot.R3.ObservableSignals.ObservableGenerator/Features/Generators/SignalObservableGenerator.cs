using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using LokiCat.GodotNodeInterfaces.Observables.ObservableGenerator.Features.SyntaxHelpers;

namespace LokiCat.GodotNodeInterfaces.Observables.ObservableGenerator.Features.Generators;

[Generator]
public sealed class SignalObservableGenerator : ISourceGenerator
{
    private const string DIAGNOSTIC_ID = "SIGOBS001";
    private const string DIAGNOSTIC_CATEGORY = "SignalObservables";
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        EmitSignalObservableExtensions(context);

        var syntaxTrees = context.Compilation.SyntaxTrees;

        foreach (var tree in syntaxTrees)
        {
            ProcessTree(context, tree);
        }
    }

    private static void ProcessTree(GeneratorExecutionContext context, SyntaxTree tree)
    {
        var root = tree.GetRoot();

        var delegateDeclarations = root
                                   .DescendantNodes()
                                   .OfType<DelegateDeclarationSyntax>()
                                   .Where(d => d.AttributeLists
                                                .SelectMany(a => a.Attributes)
                                                .Any(attr => attr.Name.ToString().Contains("Signal")));

        foreach (var delegateDecl in delegateDeclarations)
        {
            ProcessDelegate(delegateDecl, context);
        }
    }

    private static void ProcessDelegate(DelegateDeclarationSyntax delegateDecl, GeneratorExecutionContext context)
    {
        var parameters = delegateDecl.ParameterList.Parameters;
        var paramCount = parameters.Count;

        if (paramCount > 5)
        {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    DIAGNOSTIC_ID,
                    title: "Signal has too many parameters",
                    messageFormat: "[Signal] delegate '{0}' has more than 5 parameters — observable not generated.",
                    category: DIAGNOSTIC_CATEGORY,
                    DiagnosticSeverity.Warning,
                    isEnabledByDefault: true),
                delegateDecl.GetLocation(),
                delegateDecl.Identifier.Text
            );
            context.ReportDiagnostic(diagnostic);

            return;
        }

        var signalName = delegateDecl.Identifier.Text.Replace("EventHandler", "");
        var paramTypes = parameters.Select(p => p.Type?.ToString() ?? "object").ToList();
        var observableType = paramTypes.Count switch
        {
            0 => "Unit",
            1 => paramTypes[0],
            2 => $"({paramTypes[0]}, {paramTypes[1]})",
            3 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]})",
            4 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]}, {paramTypes[3]})",
            5 => $"({paramTypes[0]}, {paramTypes[1]}, {paramTypes[2]}, {paramTypes[3]}, {paramTypes[4]})",
            _ => throw new System.InvalidOperationException()
        };

        var classDecl = delegateDecl.Parent as ClassDeclarationSyntax;

        if (classDecl is null)
        {
            return;
        }

        var className = classDecl.Identifier.Text;
        var ns = Namespace.GetNamespace(classDecl);
        var code = GenerateObservablePropertyCode(ns, className, signalName, observableType);

        context.AddSource($"{className}.{signalName}.g.cs", code);
    }

    private static string GenerateObservablePropertyCode(string ns, string className, string signalName,
        string observableType)
    {
        var fieldName = $"_on{signalName}";
        var propertyName = $"On{signalName}";

        return $$"""
                 // <auto-generated />
                 using Godot;
                 using R3;

                 namespace {{ns}};

                 public partial class {{className}} {
                   private Observable<{{observableType}}> {{fieldName}};
                   public Observable<{{observableType}}> {{propertyName}} =>
                     this.Signal(nameof({{signalName}}), ref {{fieldName}});
                 }
                 """;
    }

    private static void EmitSignalObservableExtensions(GeneratorExecutionContext context)
    {
        SignalObservableExtensionGenerator.EmitSignalObservableExtensions(context);
    }
}