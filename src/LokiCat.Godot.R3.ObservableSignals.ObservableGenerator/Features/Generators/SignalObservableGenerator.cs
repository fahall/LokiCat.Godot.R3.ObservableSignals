// <auto-generated>

using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.SyntaxHelpers;

namespace LokiCat.Godot.R3.ObservableSignals.ObservableGenerator.Features.Generators;

[Generator]
public sealed class SignalObservableGenerator : ISourceGenerator
{
    private const string DIAGNOSTIC_ID = "SIGOBS001";
    private const string DIAGNOSTIC_CATEGORY = "SignalObservables";

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        SignalObservableExtensionGenerator.EmitSignalObservableExtensions(context);
        ValidateEnvironment(context);
        foreach (var tree in context.Compilation.SyntaxTrees)
        {
            ProcessTree(context, tree);
        }
    }

    private static void ValidateEnvironment(GeneratorExecutionContext context)
    {
        if (UnitTypeIsMissing(context.Compilation))
        {
            var descriptor = new DiagnosticDescriptor(
                id: DIAGNOSTIC_ID,
                title: "Missing R3.Unit type",
                messageFormat: "The R3.Unit type must be defined for zero-parameter signals. Define 'public readonly struct Unit' in namespace 'R3'.",
                category: DIAGNOSTIC_CATEGORY,
                DiagnosticSeverity.Warning,
                isEnabledByDefault: true
            );

            context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
        }
    }

    private static void ProcessTree(GeneratorExecutionContext context, SyntaxTree tree)
    {
        var root = tree.GetRoot();
        var delegateDeclarations = root
            .DescendantNodes()
            .OfType<DelegateDeclarationSyntax>()
            .Where(d => d.AttributeLists
                .SelectMany(a => a.Attributes)
                .Any(attr =>
                {
                    var name = attr.Name.ToString();
                    return name.Contains("Signal") || name.Contains("RxProperty");
                }));

        foreach (var delegateDecl in delegateDeclarations)
        {
            ProcessDelegate(context, delegateDecl);
        }
    }

    private static void ProcessDelegate(GeneratorExecutionContext context, DelegateDeclarationSyntax delegateDecl)
    {
        var parameters = delegateDecl.ParameterList.Parameters;
        var paramCount = parameters.Count;

        if (paramCount > 5)
        {
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    DIAGNOSTIC_ID,
                    title: "Signal has too many parameters",
                    messageFormat: "[Signal] delegate '{0}' has more than 5 parameters — observable not generated.",
                    category: DIAGNOSTIC_CATEGORY,
                    DiagnosticSeverity.Warning,
                    isEnabledByDefault: true),
                delegateDecl.GetLocation(),
                delegateDecl.Identifier.Text
            );
            context.ReportDiagnostic(diagnostic);
            return;
        }

        var delegateName = delegateDecl.Identifier.Text;
        if (!delegateName.EndsWith("EventHandler")) return;

        var signalName = delegateName[..^"EventHandler".Length];

        var hasRxProperty = delegateDecl.AttributeLists
            .SelectMany(a => a.Attributes)
            .Any(attr => attr.Name.ToString().Contains("RxProperty"));

        var hasSignal = delegateDecl.AttributeLists
            .SelectMany(a => a.Attributes)
            .Any(attr => attr.Name.ToString().Contains("Signal"));

        if (!hasRxProperty && !hasSignal) return;

        var classDecl = delegateDecl.Parent as ClassDeclarationSyntax;
        if (classDecl is null) return;

        ValidateDoesNotEmitSignalManually(classDecl, signalName, context);

        var className = classDecl.Identifier.Text;
        var ns = Namespace.GetNamespace(classDecl);
        var model = context.Compilation.GetSemanticModel(delegateDecl.SyntaxTree);

        var observableType = paramCount switch
        {
            0 => "Unit",
            1 => model.GetTypeInfo(parameters[0].Type!).Type.GetFullTypeName(),
            2 => $"({model.GetTypeInfo(parameters[0].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[1].Type!).Type.GetFullTypeName()})",
            3 => $"({model.GetTypeInfo(parameters[0].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[1].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[2].Type!).Type.GetFullTypeName()})",
            4 => $"({model.GetTypeInfo(parameters[0].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[1].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[2].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[3].Type!).Type.GetFullTypeName()})",
            5 => $"({model.GetTypeInfo(parameters[0].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[1].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[2].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[3].Type!).Type.GetFullTypeName()}, {model.GetTypeInfo(parameters[4].Type!).Type.GetFullTypeName()})",
            _ => throw new InvalidOperationException()
        };

        if (hasRxProperty)
        {
            EmitRxProperty(context, className, ns, signalName, observableType);
        }
        else
        {
            EmitObservable(context, className, ns, signalName, paramCount, observableType);
        }
    }

    private static void EmitObservable(GeneratorExecutionContext context, string className, string ns, string signalName, int paramCount, string observableType)
    {
        var fieldName = $"_on{signalName}";
        var connectedFlag = $"_{char.ToLowerInvariant(signalName[0])}{signalName[1..]}Connected";
        var propertyName = $"On{signalName}";
        var emitCall = paramCount switch
        {
            0 => $"EmitSignal(nameof({signalName}))",
            1 => $"EmitSignal(nameof({signalName}), value!)",
            _ => $"EmitSignal(nameof({signalName}), {string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"value.Item{i}"))})"
        };

        var source = $$"""
        // <auto-generated />
        using Godot;
        using R3;
        using System.CodeDom.Compiler;

        namespace {{ns}};

        public partial class {{className}} {
          private readonly Subject<{{observableType}}> {{fieldName}} = new();
          private bool {{connectedFlag}};

          [GeneratedCode("SignalObservableGenerator", "1.0.0")]
          public Observable<{{observableType}}> {{propertyName}} {
            get {
              if (!{{connectedFlag}}) {
                {{connectedFlag}} = true;
                {{fieldName}}.Subscribe(value => {{emitCall}}).AddTo(this);
              }
              return {{fieldName}};
            }
          }
        }
        """;

        context.AddSource($"{className}.{propertyName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static void EmitRxProperty(GeneratorExecutionContext context, string className, string ns, string signalName, string observableType)
    {
        var fieldName = $"_is{signalName}";
        var connectedFlag = $"_is{signalName}Connected";
        var propertyName = $"Is{signalName}";

        var emitCall = observableType == "Unit"
            ? $"EmitSignal(nameof({signalName}))"
            : $"EmitSignal(nameof({signalName}), value)";

        var source = $$"""
        // <auto-generated />
        using Godot;
        using R3;
        using R3.ReactiveProperty;
        using System.CodeDom.Compiler;

        namespace {{ns}};

        public partial class {{className}} {
          private readonly IRxVar<{{observableType}}> {{fieldName}} = new RxVar<{{observableType}}>();
          private bool {{connectedFlag}};

          [GeneratedCode("SignalObservableGenerator", "1.0.0")]
          public IRxProp<{{observableType}}> {{propertyName}} {
            get {
              if (!{{connectedFlag}}) {
                {{connectedFlag}} = true;
                _on{{signalName}}.AsObservable().Subscribe(value => {{emitCall}}).AddTo(this);
              }
              return {{fieldName}};
            }
          }
        }
        """;

        context.AddSource($"{className}.{propertyName}.rx.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static bool UnitTypeIsMissing(Compilation compilation)
    {
        return compilation.GetTypeByMetadataName("R3.Unit") is null;
    }

    private static void ValidateDoesNotEmitSignalManually(
        ClassDeclarationSyntax classDecl,
        string signalName,
        GeneratorExecutionContext context)
    {
        if (!EmitsSignalManually(classDecl, signalName)) return;

        var descriptor = new DiagnosticDescriptor(
            id: "SIGOBS003",
            title: "Manual EmitSignal bypasses observable",
            messageFormat: "EmitSignal(\"{0}\") is called directly, but will not emit to On{0} unless you also call _on{0}.OnNext(...).",
            category: "SignalObservables",
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true
        );

        context.ReportDiagnostic(Diagnostic.Create(descriptor, classDecl.Identifier.GetLocation(), signalName));
    }

    private static bool EmitsSignalManually(ClassDeclarationSyntax classDecl, string signalName)
    {
        return classDecl.DescendantNodes()
                        .OfType<InvocationExpressionSyntax>()
                        .Any(invocation =>
                                 invocation.Expression is MemberAccessExpressionSyntax memberAccess &&
                                 memberAccess.Name.Identifier.Text == "EmitSignal" &&
                                 invocation.ArgumentList.Arguments.Count > 0 &&
                                 invocation.ArgumentList.Arguments[0].ToString()
                                           .Contains(signalName, StringComparison.OrdinalIgnoreCase)
                        );
    }
}
